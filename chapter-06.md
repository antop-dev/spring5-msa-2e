# 6장. 마이크로서비스의 진화: 사례 연구

일체형 아키텍처<sup>`monolithic architecture`</sup> → 차세대 마이크로서비스 아키텍처

* 일체형 시스템에서 마이크로서비스로 전환하는 브라운필드 항공의 실무 사례
* 마이크로서비스로 마이그레이션하는 다양한 방법과 전략
* 스프링 프레임워크 컴포넌트를 이용해 PSS 애플리케이션을 대체할 새로운 마이크로서비스 설계
* 스프링 프레임워크와 스프링 부트를 이용한 마이크로서비스 구현

## 일체형의 죽음

처음에는 잘 작동 했지만... 사업이 성장하고 문제가 발생하기 시작했다.

### 문제점

변경 비용과 변경을 반영하는 속도가 늦어졌다.

* 더 많은 거래를 수용할 수 있는 서버를 충분히 사용하지 못하게 한다 → 스레드가 멈춤
* 작은 코드 변경에도 전체 재배포 → 서버 시작 기간이 길어짐 → 중단 시간이 길어짐
* 변경 사항을 구현하는 데에 있어서 원칙 부족 → 코드의 복잡도 증가

성능 문제는 스케일 큐브의 Y축 확장 방법을 적용하여 클러스터/오라클 RAC 구성으로 해결하려 했다. 하지만 **복잡도 증가, 비용의 증가 등 문제가 생겼다.** 

![](https://i.imgur.com/c5rwZQZ.png)

### 회고

잘 설계된 애플리케이션이 왜 기대에 부응하지 못했는지 의문이 생긴다.

* 모듈화보다 데이터 공유 우선
* 일체형 단일 데이터베이스
* 저장 프로시저
* 도메인 경계 침범

> 개발자들은 제대로 된 해결책을 찾기보다는 빠른 해결책을 찾기 시작했다.<br/>
> 느리지만 꾸준하게 애플리케이션의 모듈성이 사라져갔다.

## 마이크로서비스 구조대: 계획적 마이그레이션

혁명적인 모델보다는 진화적인 접근방식으로 시스템을 새로 정립하려고 한다.

### 비지니스 사례 `p285`

마이크로서비스 아키텍처에서는 향후 5년 내에 동일한 문제가 발생하지 않게 만들기 위해 어떤 전략을 취하는가?

* 서비스 의존성
* 물리적 경계
* 선택적 확장
* 기술 노후화

### 마이그레이션 방식 `p285`

전환<sup>`transition`</sup> 계획을 수립하고, 점진적으로 기능을 마이크로서비스에 옮긴다.

* 마이크로 경계 식별
* 마이그레이션을 위한 마이크로서비스 우선 순위 지정
* 전환 단계에서의 데이터 동기화 처리
* 새로운 시스템에서의 참조 데이터 처리

### 마이크로서비스 경계 식별 `p287`

마이크로서비스로의 전환을 위한 분해 과정은 비지니스 범위나 또는 경계 지어진 컨텍스트<sup>`Bounded Context`</sup>의 수준을 넘어서는 안된다.

도메인 분해
* 상향식 접근법
* 하향식 접근법

※ [서비스 지향 시스템 개발에서 하향식(Top-down) 접근과 상향식(Bottom-up) 접근 비교](https://seulkom.tistory.com/64)

### 의존 관계 분석

복잡한 의존 관계를 분석하고 개선해서 더 단순한 의존 관계로 만든다.

1. 쿼리와 대조되는 이벤트 `p290`
2. 동기적 업데이트와 대조되는 이벤트 `p291`
3. 까다로운 요구사항 `p293` 
4. 까다로운 소비스 경계 `p294`

### 마이그레이션을 위한 마이크로서비스 우선순위 지정 `p299`

우선순위를 분석하고 **마이그레이션 순서**를 정한다.

* 의존 관계
* 트랜잭션 크기
* 리소스 이용률
* 복잡도
* 사업 중요도
* 변경 속도
* 혁신

### 마이그레이션 중의 데이터 동기화

전환 단계 동안 레거시 시스템과 새로운 마이크로서비스는 병렬적으로 운영된다. 따라서 둘 간의 데이터를 동기화하는 것이 중요하다.

* 데이터 동기화 도구를 이용해 데이터베이스 수준에서 동기화
* 이벤트를 받아 처리하는 컴포넌트를 새로 만들어 레거시 모듈을 변경하지 않아도 되게 한다.

### 참조 데이터 관리

일체형 애플리케이션을 마이크로서비스로 이전하는 과정에서 맞닥뜨리는 가장 큰 문제는 참조 데이터를 관리하는 것이다.

* 참조 데이터를 담당하는 마이크로서비스를 만듬. 성능 문제가 발생할 수 있다.
   
   ![Imgur](https://i.imgur.com/FMzR6kf.png)
   
* 모든 관리자와 CRUD 기능을 위함 참조 데이터 마이크로서비스를 만드는 것

    ![Imgur](https://i.imgur.com/NUIf8Pb.png)
    
* 로컬 캐시를 인메모리 데이터 그리드<sup>`in-memory data grid`</sup>로 교체하는 방법

    ![Imgur](https://i.imgur.com/ZdWb1k9.png)
    
    * [Hazelcast](https://hazelcast.com/)
    * [Redis](https://redis.io/)
    
### 사용자 인터페이스와 웹 애플리케이션

전이<sup>`transition`</sup> 단계에서는 이전 UI와 새로운 UI 모두를 유지해야 한다.

1. 이전 UI와 새로운 UI 사이에 연결 고리 없이 분리된 사용자 애플리케이션으로 만드는 방법
2. 레거시<sup>`Legacy`</sup> UI를 주 애플리케이션ㅇ로 사용하고 사용자가 새로운 애플리케이션의 페이지를 요청하면 새로운 UI로 페이지 이동시켜주는 방법
3. 레거시 UI를 새로운 마이크로서비스 백엔드에 바로 통합시키는 방법

※ 2,3 방법에서의 또다른 문제는 서비스와 리소스의 인증을 어떻게 할 것인가?

### 생태계 역량 구축

마이크로서비스를 시작 하기 전에 현재 환경이 마이크로서비스를 수용할 수 있는지 판단해야 한다.

* CI/CD
* 보안과 통합 인증
* 모니터링

### 모듈 마이그레이션은 필요할 때만

모든 모듈을 마이크로서비스 구조로 옮길 필요는 없다!

### 예외 처리

* 재시도<sup>`retry`</sup>
* 서킷 브레이커<sup>`circuit breaker`</sup>
* 폴백<sup>`fallback`</sup>

## 구현 목표

![](https://i.imgur.com/E0NHSRd.png)

* [chapter-06.book](chapter-06.)
* [chapter-06.checkin](chapter-06.checkin)
* [chapter-06.fares](chapter-06.fares)
* [chapter-06.search](chapter-06.search)
* [chapter-06.website](chapter-06.website)

※ Search 페이지에서 발생하는 에러 수정

```java
public class UIData {
    // 처음부터 만들어져 있어야 폼의 값이 @ModelAttribute에 의해서 바인딩 됨
    private final SearchQuery searchQuery = new SearchQuery();
    private List<Flight> flights;
    private Flight selectedFlight;
    private Passenger passenger;
    // bookingid → bookingId
    private String bookingId;
}
```
