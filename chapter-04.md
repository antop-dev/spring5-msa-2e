# 4장. 마이크로서비스 개념 적용

마이크로서비스는 한 마디로 좋다. 하지만 그 개념이 올바르게 자리 잡지 않는다면 해로울 수도 있다. 마이크로서비스에 대한 잘못된 해석과 잘못된 석택은 돌이킬 수 없는 실패로 이어질 수도 있다.

* 다양한 설계 선택 사이의 트레이드오프<sup>`trade-off`</sup>
* 마이크로서비스를 개발할 때 고려할 만한 패턴
* 확장성 있는 일류<sup>`first-class`</sup> 마이크로서비스 설계에 필요한 일반적인 가이드라인

## 마이크로서비스 설계 가이드라인

일반적으로 가볍고 모듈화돼 있으며 확장 가능한 분산 시스템을 만드는 데 마이크로서비스는 아주 훌륭한 선택이다. 

### 마이크로서비스 경계 설정

마이크로서비스의 크기

* 마이크로서비스 하나당 하나의 REST 종단점
* 300라인 이하의 코드
* 하나의 책임만을 지는 컴포넌트

마이크로서비스의 경계를 정의하는 방법

* 자율적인 기능
* 배포 단위의 크기
* 분리하기에 가장 저갑한 기능 또는 서브도메인
* 폴리글랏<sup>`polyglot`</sup> 아키텍처
* 선택적 확장
* 애자일 팀과 협력 개발
* 단일 책임: `CQRS` <sup>`Command Query Responsibility Segregation`</sup>
* 복제 가능성과 변경 가능성
* 결합과 응집
* 마이크로서비스를 하나의 제품으로 생각하기

### 통신 방식 설계

![Imgur](https://i.imgur.com/Ag095JK.png)

* 동기 방식: 요청-응답
* 비동기 방식: 발동-망각<sup>`fire and forget`</sup>
* 동기와 비동기, 선택의 기준
* 리액티브<sup>`reactive`</sup> 프로그래밍

### 마이크로서비스 오케스트레이션

조립성<sup>`composability`</sup>은 서비스 디자인 원칙 중 하나인데, 서비스를 조립하는 쪽에 복잡함이 집중된다.<br/>
서비스 지향 아키텍처에서는 서비스를 조립하는 방식이 크게 두 가지로 나눠진다. 

* 오케스트레이션<sup>`orchestration`</sup> : 오케스트레이터가 여러 개의 서비스를 모아 하나의 완전한 기능을 만든다.

    ![Imgur](https://i.imgur.com/N4gqYil.png)   

* 연출<sup>`choreography`</sup>: 생산자<sup>`producer`</sup>쪽에서 이벤트가 발생되면 다수의 소비자<sup>`consumer`</sup>는 이벤트를 독립적으로 처리한다.

    ![Imgur](https://i.imgur.com/sVoTRRb.png)

자율성 원칙에 따르면 마이크로서비스 외부에 존재하는 컴포넌트가 흐름을 제어하는 것은 바람직한 선택이 아니다.

* [넷플릿스 컨덕터<sup>`Conductor`</sup>](https://netflix.github.io/conductor/)

### 마이크로서비스 하나에 얼마나 많은 종단점을 둘 것인가?

종단점의 수는 중요한 결정 사항이 아니다. 마이크로서비스 크기에 적합하게 경계 지어진 컨텍스트를 적절하게 설계하는 것이 훨씬 더 중요하다.

### 가상머신 하나당 하나의 마이크로서비스 또는 다수의 마이크로서비스?

성숙한 가상화 인프라스트럭처나 클라우드 인프라스트럭처를 보유하고 있는 조직에서는 여러 개의 마이크로서비스를 하나의 가상머신에서 실행하는지 여부는 사실 큰 문제가 아니다.

### 룰 엔진: 공유 또는 내장?

* 직접 비지니스 룰을 코딩

    ![Imgur](https://i.imgur.com/31RY7XU.png)  

* 내장 룰 엔진

    ![Imgur](https://i.imgur.com/C6pd7U7.png)

* 내장 룰 엔진 & 중앙의 저장소: [드룰즈<sup>`Drools`</sup>](https://www.drools.org/)

    ![Imgur](https://i.imgur.com/txhWZGZ.png)

### BPM의 역할과 작업 흐름

BPM<sup>`Business Process Management`</sup>과 iBPM<sup>`Intelligent BPM`</sup>은 비지니스 프로세스의 설계, 실행, 모니터링을 담당하는 도구 세트다. BPM은 레거시 애플리케이션 서비스뿐 아니라 마이크로서비스도 호출하며, 사람이 하는 일도 통합한다.

BPM은 시스템과 사람의 상호작용을 자동화함으로써 전 구간의 여러 기능에 걸쳐있는 비지니스 프로세스를 모델링하는 상황에서 ㅅ여러 개의 마이크로서비스를 조합하는 상위 수준에서 사용될 수 있다.

### 마이크로서비스가 데이터 스토어를 공유할 수 있는가?

원칙적으로 마이크로서비스는 표현 계층, 비지니스 로직, 데이터 스토어를 추상화해야 한다. 공유 데이터 모델, 공유 스키마, 공유 테이블은 좋지 못한 방법이며, 마이크로서비스 개발을 **재앙**으로 이끌 수도 있다.

여러 개의 마이크로서비스에 공유 데이터베이스를 사용하는 시나리오가 있을 수 있다.

대안은 마이크로서비스에 **필요한 데이터 스토어**를 공통 데이터 저장소에서 **분리**해 마이크로서비스 내에서 사용하는 것이다.

![Imgur](https://i.imgur.com/b8x1n19.png)

마이크로서비스가 데이터 호수<sup>`Data Lake`</sup>나 마스터 데이터 관리 등 공통 데이터 저장소<sup>`Common Data Repositories`</sup>같은 데이터 저장소를 공유해야만 하는 시나리오도 있을 수 있다.

이럴 때는 어쩔 수 없이 공유 데이터를 사용할 수 밖에 없으며, 해당 데이터 저장소에 직접 붙는 대신 서비스인터페이스를 둬서 마이크로서비스와 데이터 저장소를 간접화하고 결합 관계를 끊는 것이 중요하다.

### 마이크로서비스는 화면이 꼭 필요한가?

마이크로서비스는 UI 없이 사용될 때도 많은데 이런 마이크로서비스를 화면 없는<sup>`headless`</sup> 마이크로서비스라고 부른다.

### 트랜잭션 경계 설정

트랜잭션 내의 여러 작업은 커밋으로 모두 함께 확정되거나 롤백으로 모두 취소된다. 분산 시스템에서는 2단계 커밋<sup>`2 phase commit`</sup>과 함께 분산 트랜잭션의 개념을 사용한다.

* 트랜잭션 요구 사항을 단순화하기 위한 사용 사례의 변경
* 분산 트랜잭션 시나리오
* [TCC<sup>`Try-Confirm/Cancel`</sup>](https://dzone.com/articles/transactions-for-the-rest-of-us)
* [마이크로서비스 - 트랜잭션](https://baramnemse.github.io/blog/6/)

### 서비스 종단점 설계 고려 사항

서비스 설계에는 계약 설계<sup>`contract design`</sup>와 프로토콜 선택<sup>`protocol selection`</sup>이라는 두 가지 핵심 요소를 포함한다.

#### 계약 설계

* KISS<sup>`Keep It Simple Stupid`</sup> : 바보스러울 만큼 단숨함을 유지
* YAGNI<sup>`You Ain'y Gonna Need It`</sup> : 필요 없는 기능은 만들지 않기
* 진화적 설계<sup>`evolutionary design`</sup> : 현재 필요한 만큼만 충분히 설계하고, 새로운 기능이 필요할 때 설계를 변경하고 리팩터링을 지속한다.
* 소비자 주도 계약<sup>`CDC`, `Consumer Driven Contracts`</sup> : 사용자가 원하는 기대 사항을 서비스 제공자에게 테스트 케이스의 형태로 제공하게 함으로써 시비스 계약이 변경될 때마다 서비스 제공자가 통합 테스트할 수 있게 해준다. 
* 포스텔의 법칙<sup>`Postel's law`</sup>

#### 프로토콜 선택

* 메시지 지향 서비스
* HTTP와 REST 종단점 : HTTP, REST, JSON, HATEOAS, RFC 5988 - 웹 링킹<sup>`Web Linking`</sup>
* 최적화된 통신 프로토콜 : 아브로<sup>`Avro`</sup>, 프로토콜 버퍼<sup>`Protocol Buffers`</sup>, 스리프트<sup>`Thrift`</sup>

### 공유 라이브러리 처리

* 공통 라이브러리를 복제하여 사용
* 공통 코드를 복제하여 사용
* 공통되는 부분을 별도의 마이크로서비스로 떼어내어 사용

### 마이크로서비스에서의 사용자 인터페이스

* UI, 비지니스 로직, 데이터베이스를 모두 담고 있는 마이크로서비스
* 이미 존재하는 API를 매시업<sup>`mashup`</sup>해서 UI를 포함한 모바일 애플리케이션
* 특정 커뮤니티에 특화된 통합 웹 애플리케이션
* 뒷단에 있는 여러개의 마이크로서비스에 연결을 해주는 컨테이너 웹 애플리케이션이나 플레이스홀더<sup>`placeholder`</sup> 웹 애플리케이션

### 마이크로서비스의 API 게이트웨이

서버에서 화면까지 제공하기보다는 RESTful 서비스를 노출하고 클라이언트 측(`Anguler`, `React`, `Vue`...)에서 사용하는 방식으로 개발되고 있다.

* 계약에 대한 기대 사항의 불일치
* 하나의 페이지를 렌더링하기 위해 서버에 여러 번의 요청을 날리게 된다.

해결법

1. `HETEOAS` 방식으로 최소한의 정보만을 링크 정보와 함께 전달
2. 클라이언트가 REST 요청을 보낼 때 **쿼리 문자열로 필요한 필드를 지정해서 요청**
3. 간접화 개념을 사용. 클라이언트와 서버 사이에 있는 게이트웨이 컴포넌트가 데이터 소비자의 명세에 따라 데이터를 변환

### ESB 및 iPaas와 마이크로서비스의 사용

마이크로서비스 세상에는 `ESB`가 존재할 공간이 남아있지 않다.

| 기능 | ESB | MSA |
| :--- | :---: | :--- |
| 제한된 ESB | ○ | API Gateway |
| 오케스트레이션 | ○ | 연출<sup>`choreography`</sup> |
| 프로토콜 중재 | ○ | `REST`/`JSON` |

### 서비스 버저닝 고려 사항

서비스가 진화하게 할 때 고려해야 하는 중요 사항은 서비스 버저닝<sup>`versioning`</sup>이다.

* 시맨틱<sup>`semantic`</sup> 버저닝

REST 서비스에서 사용할 수 있는 버저닝 방식

* URI 버저닝
* 미디어 타입 머저닝
* 커스텀 헤더

### 크로스오리진 설계

CORS<sup>`Cross Origin Resource Sharing`, `도메인 간 자원 공유`</sup>

마이크로서비스에서는 서비스가 동일한 호스트나 동일한 도메인에서 운영된다는 보장이 없다.

### 공유 참조 데이터 처리

대규모 애플리케이션을 분리할 때 공통적으로 나타나는 문제 중 하나는 마스터 데이터나 참조 데이터의 관리 문제다.

* 상대적으로 정적이고 변경될 가능성이 전혀 없는 데이터는 각 서비스에서 하드코드
* 공통으로 사용되는 데이터를 별도의 마이크로서비스로 빼는 방법
* 데이터를 모든 마이크로서비스에 복제하는 방법
* 필요한 데이터를 로컬에 캐시해서 갖고 있는 방식: Ehcache, 헤이즐캐스트<sup>`Hazelcast`</sup>, 인피니스팬<sup>`Infinispan`</sup>

### 마이크로서비스와 대규모 데이터 작업

일체형 애플리케이션을 더 작고 목적에 맞는 서비스로 나누면 여러 마이크로서비스 데이터 스토어에서 **조인 쿼리를 통해 데이터를 가져올 수 없게 된다**.

* 데이터가 생성될 때 사전 집계
* 배치<sup>`batch`</sup> API : Spring 배치<sup>`Batch`</sup>